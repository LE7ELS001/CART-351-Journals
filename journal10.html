<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Journals</title>
    <link rel="stylesheet" href="css/style.css">
</head>

<body>
    <div class="scanline"></div>
    <div class="container">

        <div class="pixel-corner top-left"></div>
        <div class="pixel-corner top-right"></div>
        <div class="pixel-corner bottom-left"></div>
        <div class="pixel-corner bottom-right"></div>


        <div class="alien alien-1"></div>
        <div class="alien alien-2"></div>
        <div class="alien alien-3"></div>

        <div class="content-box">
            <div class="title">
                <h1>Journal #9</h1>
            </div>

            <div class="divider"></div>

            <div class="content">
                <p><strong>December 5</strong></p>


                <div class="content-text">
                    <h2> PROJECT III</h2>
                    This week, my teammate Tianshun and I began working on Project 3, where we decided to create a
                    multiplayer online
                    fighting game.

                    During development, we learned more about the workflow behind real-time networked games. Unlike
                    building a single-player
                    game, every new feature on the front end requires us to consider whether the change needs to be
                    synchronized to the
                    backend and how that synchronization should happen. Instead of completing the front end first,
                    development becomes a
                    constant back-and-forth between client logic and server communication.

                    I also gained a better understanding of networking behavior in multiplayer systems. One memorable
                    example was the logic
                    for handling player join events. We discovered a bug where Player 1 could see Player 2, but Player 2
                    could not see
                    Player 1. After debugging, we realized the issue occurred because Player 1 broadcasted their join
                    message before Player
                    2 existed, so Player 2 never received it. The fix was to allow late-joining players to request the
                    current player list
                    instead of relying solely on broadcast events. This experience helped me understand that matchmaking
                    and synchronization
                    in programming require multiple steps rather than a single action.

                    Another takeaway was gaining a clearer understanding of the separation between frontend and backend
                    responsibilities.
                    For example, the shared timer must run on the server to ensure both players remain synchronized,
                    while local mechanics
                    like collision detection can run on the client and simply send the result back to the server.

                    Overall, this project helped me better understand the practical use of WebSockets, Socket.IO, and
                    MongoDB, and it gave
                    me a clearer sense of how multiplayer development differs fundamentally from single-player game
                    development.



                </div>
            </div>
        </div>

        <div class="navigation">
            <a href="journal9.html" class="nav-btn prev">â—€ Previous</a>
            <a href="index.html" class="nav-btn prev">Home</a>
            <a href="" class="nav-btn next"></a>
        </div>
    </div>
</body>

</html>